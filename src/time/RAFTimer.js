/**
* (c) Christian Schlosrich 2012
* A timer build on requestAnimationFrame. Timer will pause when rAF stops firing and resume when rAF resumes.
* Timer can either be based on miliseconds or frames
* Useful for linking game timers to animation based of rAF.
* 
* @param {Number} duration in miliseconds or number of frames, if useFrames is set to true
* @param {Function} notify callback
* @param {Boolean} useFrames false (default) makes the timer use miliseconds. True forces it to frame based timing.
*/
fx.RAFTimer = function(duration, notify, useFrames){

    /**
    * Validating args
    */
    if(!window.requestAnimationFrame || !window.cancelAnimationFrame){
        throw new Error('requestAnimationFrame and cancelAnimationFrame are required for RAFTimer.');
    } else if(!duration){
        throw new Error('Missing required parameter \'duration\'.');
    } else if(isNaN(duration)){
        throw new Error('Parameter \'duration\' is not a Number.');
    } else if(!notify){
        throw new Error('Missing required parameter \'notify\'.');
    }

    /**
    * Using performance.now() when available (recently introduced HTML5 feature)
    * The precesion timer does not affect frame based timing
    * http://updates.html5rocks.com/2012/08/When-milliseconds-are-not-enough-performance-now
    */
 	window.performance = window.performance || {};
    performance.now = performance.now || performance.webkitNow || performance.mozNow || performance.msNow || performance.oNow;

    if(!performance.now){
    	performance.now = function() {
    	   return new Date().getTime();
    	}

    	this.usePresicionTimer = false;
    } else{
    	this.usePresicionTimer = true;
    }

    this.duration = duration;
    this.notify = notify;
    this.useFrames = useFrames || false;

    // The current request ID as generated by a call to requestAnimationFrame
    this.requestId = 0;

    this.running = false;
    this.paused = false;
    this.ms = Infinity;
    this.currentTime = 0;
    this.currentFrame = 0;

    // Increased by one when timer reaches it's duration and notify is called
    this.tick = 0;

    /**
    * Max delta time threshold set at 160 ms / 6.25 fps. 
    * When frame rate drops this low we can safely assume that requestAnimationFrame has stopped firing and thus we stop accumulating time (only other viable explanation is that the user's computer is crap and can't produce a proper frame rate)
    */
    this.maxDeltaTime = 160;

    var lastTime,
    	that = this;

    this._callback = function(){
        that.currentTime = that.duration;
        that.tick++;
        that.lastTime = 0;
        that.reset();

        if(that.notify){
            that.notify.call(that);
        }
    }

    this._handleAF = function(){
    	if(!that.running || that.paused){
    		return;
    	}

        if(that.useFrames){
            if(that.currentFrame == that.duration){
                that._callback();
            }
        } else if(that.currentTime >= that.duration){
            that._callback();  
        }

    	var now = performance.now();
		that.ms = now - (lastTime || now);

        // When rAF resumes from idle state and ms is greater than 160 ms don't add the value to accumulated time (assuming the tab / window was inactive)
		if(that.ms > that.maxDeltaTime){
           that.ms = 0;
		}

		lastTime = now;

        that.currentTime += that.ms;
        that.currentFrame++;
        that.requestId = requestAnimationFrame(that._handleAF);
    }
}

fx.RAFTimer.prototype = {

    /**
    * Starts the timer (if timer is paused only resume can re-start the timer)
    */
    start : function(){
    	if(this.running || this.paused){
    		return;
    	}

    	this.running = true;
    	this.requestId = requestAnimationFrame(this._handleAF);
    },

    /**
    * Stops the timer (timer will not resume if rAF stops and is restarted)
    */
    stop : function(){
    	if(!this.running){
    		return;
    	}

    	this.running = false;
        this.paused = false;
        this.reset();
    	cancelAnimationFrame(this.requestId);
    },

    /**
    * Pauses the timer (if the timer is already running)
    */
    pause : function(){
        if(this.paused || !this.running){
            return;
        }

        this.paused = true;
    },

    /**
    * Resumes from the last current time if timer is running but paused (opposed to stop that triggers a restart once rAF continues)
    */
    resume : function(){
        if(!this.paused){
            return;
        }

        this.paused = false;
        this.requestId = requestAnimationFrame(this._handleAF);
    },

    /**
    * Returns the current time as properly formatted seconds and miliseconds (human readable).
    */
    getFormattedTime : function(){
		return (this.currentTime / 1000).toFixed(2);
    },

    /**
    * Sets the current running time to 0
    */
    reset : function(){
    	this.currentTime = 0;
        this.currentFrame = 0;
    },

    /**
    * Returns true if rAF is active (currenly intervals exceeding 160ms will result in false)
    */
    rafActive : function(){
        return ms < this.maxDeltaTime;
    },

    /**
    * Destroys the timer and remove internal references for GC.
    */
    destroy : function(){
        this.stop();
        this.notify = null;
        this.duration = null;
    },

    /**
    * Returns a String representation of fx.RAFTimer
    */
    toString : function(){
        var res = '[RAFTimer] ';

        if(this.useFrames){
            res += 'duration(frames): ' + this.duration + ', currentFrame: ' + this.currentFrame;
        } else{
            res += 'duration(ms): ' + this.duration + ', currentTime: ' + this.getFormattedTime();
        }

        res += ', tick: ' + this.tick + ', running: ' + this.running + ', paused: ' + this.paused;

        if(!this.useFrames){
            res += ', precisionTimer: ' + this.usePresicionTimer;
        }

        return res;
    }
}