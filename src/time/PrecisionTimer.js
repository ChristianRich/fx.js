/**
* (c) Christian Schlosrich 2012
* PrecisionTimer is built on requestAnimationFrame and high precision timing (if available).
* The timer will pause when requestAnimationFrame stops firing and resume when requestAnimationFrame resumes.
* The timer can either be based on miliseconds or frames
*
* When using miliseconds a slow down in framerate will NOT affect the timing. 1 seconds is 1 second no matter what the frame rate is.
* Frame based timing on the other hand IS affected by frame rate. A slower frame rate will mean that it will take longer time for the callback to fire.
* to fire. How long is impossible to say since the timing is not based on miliseconds but rater on how many 'ticks' is fired by requestAnimationFrame.
*
* @param {Number} duration in miliseconds or number of frames if useFrames is set to true
* @param {Function} notify callback
* @param {Boolean} useFrames false (default) makes the timer use miliseconds. True forces it to frame based timing.
*/
fx.PrecisionTimer = function(duration, notify, useFrames){

	if(!(this instanceof arguments.callee)){
		throw new Error('Constructor called as a function.');
	} else if(!duration){
        throw new Error('Missing required parameter \'duration\'.');
    } else if(isNaN(duration)){
        throw new Error('Parameter \'duration\' is not a Number.');
    } else if(!notify){
        throw new Error('Missing required parameter \'notify\'.');
    }

    this.duration = duration;
    this.notify = notify;
    this.useFrames = useFrames || false;

    // The current request ID as generated by a call to requestAnimationFrame
    this.requestId = 0;
	
    this.running = false;
    this.paused = false;
    this.ms = Infinity;
    this.currentTime = 0;
    this.currentFrame = 0;

	// Increased by one when timer reaches it's duration and notify is called
    this.count = 0; 

    /**
    * Max delta time threshold set at 160 ms / 6.25 fps. 
    * When frame rate drops this low we can safely assume that requestAnimationFrame has stopped firing and thus we stop accumulating time (only other viable explanation is that the user's computer is crap and can't produce a proper frame rate)
    */
    this.maxDeltaTime = 160;

    var lastTime,
    	self = this;

    this._callback = function(){
        self.currentTime = self.duration;
        self.count++;
        self.lastTime = 0;
        self.reset();
      	self.notify.call(self);
    };

    this._tick = function(){

    	if(!self.running || self.paused){
			return;
		}

		/**
		* If the time is up for either time or frame based timing notify the callback
		*/
		if(self.useFrames){
			if(self.currentFrame == self.duration){
				self._callback.call(this.context || self);
			}
		} else if(self.currentTime >= self.duration){
			self._callback.call(this.context || self);
		}

		/**
		* Optional callback for a notify on every tick
		*/
		if(self.onTick){
			self.onTick.call(this.context || self);
		}

    	var now = performance.now();
		self.ms = now - (lastTime || now);

		/**
		* When requestAnimationFrame resumes from idle state and ms is greater than 160 ms reset accumulated time
		* We have to assume that either an abnormal length of time has passed or the window / tab has been inactive
		*/
		if(self.ms > self.maxDeltaTime){
			self.ms = 0;
		}

		lastTime = now;

        self.currentTime += self.ms;
        self.currentFrame++;
        self.requestId = requestAnimationFrame(self._tick);
    }
};

fx.PrecisionTimer.prototype = {

	/**
	* Starts the timer (if timer is paused only resume can re-start the timer)
	*/
    start : function(){
    	if(this.running || this.paused) return;
    	this.running = true;
    	this.requestId = requestAnimationFrame(this._tick);
    },

	/**
	* Stops the timer (timer will not resume if rAF stops and is restarted)
	*/
    stop : function(){
    	if(!this.running) return;
    	this.running = false;
        this.paused = false;
        this.reset();
    	cancelAnimationFrame(this.requestId);
    },

	/**
	* Pauses the timer (if the timer is already running)
	*/
    pause : function(){
        if(this.paused || !this.running){
			return;
		}

        this.paused = true;
    },

	/**
	* Resumes from the last current time if timer is running but paused (opposed to stop that triggers a restart once rAF continues)
	*/
    resume : function(){
        if(!this.paused){
			return;
		}

        this.paused = false;
        this.requestId = requestAnimationFrame(this._tick);
    },

	/**
	* Returns the current time as properly formatted seconds and miliseconds (human readable).
	*/
    getFormattedTime : function(){
		return (this.currentTime / 1000).toFixed(2);
    },

	/**
	* Sets the current running time to 0
	*/
    reset : function(){
    	this.currentTime = 0;
        this.currentFrame = 0;
    },

	/**
	* Returns true if rAF is active (currenly intervals exceeding 160ms will result in false)
	*/
    rafActive : function(){
        return this.ms < this.maxDeltaTime;
    },

	/**
	* Destroys the timer and remove internal references for GC.
	*/
    destroy : function(){
        this.stop();
        this.notify = null;
        this.duration = null;
    },

	bind : function(context){
		this.context = context;
		return this;
	},

	/**
	* Returns a String representation of fx.PrecisionTimer
	*/
    toString : function(){
        var res = '[PrecisionTimer] ';

        if(this.useFrames){
            res += 'duration in frames: ' + this.duration + ', currentFrame: ' + this.currentFrame;
        } else{
            res += 'duration in ms: ' + this.duration + ', currentTime: ' + this.getFormattedTime();
        }

        res += ', count: ' + this.count + ', running: ' + this.running + ', paused: ' + this.paused + ', ms: ' + this.ms.toFixed(2);
        return res;
    }
};